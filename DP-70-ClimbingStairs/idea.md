#### 四步走战略
* step1: 确定状态： 当没有台阶的时候是1，当只有一个台阶的时候是1， dp[0] = dp[1] = 1;
* step2: 确定转移方程：因为只能条1个或者两个台阶，dp[x] = dp[x-2] + dp [x-1], x>=2;
* step3: 初始边界条件： dp[0] = dp[1] = 1;
* step4: 计算顺序： 从小到大。

关于dp[0] = 1? 的想法，这不仅可以从题意里里推断，还可以根据转移方程推断dp[2] = dp[1] + dp[0] = 2;
而且dp[1] = 1, 所以dp[0] 只能为1；

```javascript
    let dp = [1,1];
    //注意必须求到第n 个数
    for (let i = 2; i < n+1; i++){
        dp.push(dp[i-1] + dp[i-2]);
    }
    return dp[n];
    };
```

#### 改进版本
* 其实这个题， 没有必要把所有的过程参数都放到数组里，因为每次求新的元素的时候，都
    只有x-1 和 x-2两个位置上的数参与，所以造成了内存的浪费