#### 四步走战略
* step1: 确定状态： 
* step2: 确定转移方程：
    * 在求解dp[x]\[y](x代表了w2，y代表了w1)的时候，
    * 当w1[y] === w2[x]时：dp[x][y] = Min(dp[x-1][y]+1, dp[x][y-1], dp[x-1][y-1])
    * 当w1[y] !== w2[x]时：dp[x][y] = Min(dp[x-1][y]+1, dp[x][y-1], dp[x-1][y-1]+1)
* step3: 初始边界条件： 根据下表，初始化第一行和第一列。
* step4: 计算顺序：

#### 举例说明
* w1 = 'abcdef', w2 = 'azced', 要把w1转化成w2, 横轴w1, 纵轴w2
* 
|  | '' | a  | b  | c  | d  | e  | f  |
|---|---|---|---|---|---|---|---|
| ''  | 0 | 1 | <span style="color:red;">**2**</span> | 3 | 4 | 5 | 6 |
|  a  | 1 | 0 | 1 | 2 | 3 | 4 | 5 |
|  z  | 2 | 1 | 1 | 2 | <span style="color:Blue;">**3**</span>  | 4 | 5 |
|  c  | 3 | 2 | 2 | <span style="color:Green;">**1**</span> | 2 | 3 | 4 |
|  e  | 4 | 3 | 3 | 2 | 2 | 2 | 3 |
|  d  | 5 | 4 | 4 | 3 | 2 | 3 | 3 |
* 为什么在每一个单词前面加一个空字符：
    * 方便以后的计算
* 每一个数据表示什么？
    * 第一行红色的2表示： 字符串'ab'转化成''最少需要几步, 最少需要的是2步。
* 分别解释转移方程的两种情况。
    * 当w1[y] == w2[x]时, 看绿色字体1，该数据表示把'abc'转化成'azc'至少需要1步；根据转移方程的意思就是Min(2+1, 2+1, 1) = 1
    * 把'abc'转化成'azc'有三种情况：
      1. dp[x-1][y]表示的情况：把'abc'转化成'az'<span style="color:Pink;">**再加1**</span>，为什么还要加1? 因为我们的目的是把'abc'转化成'azc', 现在这种情况只是把'abc'转化成了'az', 还没有完成任务，还要在末尾添加一个c(这也是一个步骤所以加1)
      2. dp[x][y-1]表示的情况：把'ab'转化成'azc'<span style="color:Pink;">**再加1**</span>,把'ab' 转化成'azc'，相当于原来的'abc'变成了'azcc', 所以，还要把abc原来的c删掉(这个步骤加1)
      3. dp[x-1][y-1]表示的情况：把'ab'转化成'az'<span style="color:Pink;">**不加1**</span>，因为c都相同，所以把'ab'转化成'az'即可达成目的。
    * 当w1[y] !== w2[x]时,看蓝色的3, 该数据表示把'abcd'转化成'az', 根据转移方程的含义： Min(2+1, 2+1, 3+1) = 3.
    * 把'abcd'转化成'az'分成三种情况：

      1. dp[x-1][y]表示的情况：'abcd'转化成'a', 再加1(转化成'a'后还要在末尾添加字母'z')
      2. dp[x][y-1]表示的情况：'abc'转化成'az', 再加1('abcd'里面的'abc'转化成了'az', 但是原来的'd'还存在，需要删除)
      3. dp[x-1][y-1]表示的情况：'abc'转化成'a', 再加1('abcd'里面的'abc'转化成'a'了， 然后再把‘d’转化成'z',达成目的)